# Что это?
Это улучшенная реализация сущности под названием "декоратор", позаимствованной из ЯП Python.

В Python определение и использование типичного декоратора выглядит так (Python псевдокод):
```
# декоратор
def decorator(func):
    # may be some work
    def inner(*args, *kwargs):
        # may be yet another work
        return func(*args, *kwargs)
    inner()

# применение декоратора к определению функции
@decorator
def func(...):
    ...

# или применение декоратора без использования синтаксического сахара
func = decorator(func)
```

## Как это предлагается делать для Rust?
Я предлагаю это делать с помощью указания специального атрибута перед определением функции. Атрибут реализуется процедурным макросом, поэтому для его использования необходимо подключить специальный крэйт, в котором он определен.

Это выглядит так (Rust псевдокод):
```
#![feature(use_extern_macros)]
#![feature(proc_macro)]

extern crate decorators;
use decorators::decorators; // квалифицированный импорт использован для краткости, но, разумеется, можно его и не использовать

fn decorator1(arg: RetType) -> RetType {
    // some work
    arg
}

fn decorator2(arg: RetType) -> RetType {
    // some work
    arg
}

#[decorators(decorator1, decorator2)]
fn func(arg: SomeType) -> RetType {
    ...
}
```

    "decorators(decorator1, decorator2)": "decorators" - подключенный процедурный макрос-атрибут,
                                          "decorator1, decorator2" - список декораторов; декораторы будут применяться в порядке обратном тому, в котором они здесь указаны.

В результате применения атрибута во время компиляции исходное определение функции будет заменено на определения двух сгенерированных функций:
```
// тело исходной функции с другим, сгенерированным именем (генерация тривиальна, возможны коллизии)
fn decorator1_decorator2(arg: SomeType) -> RetType {
    ...
}

// имя исходной функции с другим, сгенерированным телом
fn func(arg: SomeType) -> RetType {
    decorator1(decorator2(decorator1_decorator2(arg)))
}
```

Также есть возможность указывать дополнительные аргументы для декораторов:
```
fn decorator1(message: &str, message1: &str, arg: RetType) -> RetType {
    // some work
    println!("{} {}!", message, message1);
    arg
}

fn decorator2(arg: RetType) -> RetType {
    // some work
    arg
}

#[decorators(decorator1("`decorator1`", "called"), decorator2)]
fn func(arg: SomeType) -> RetType {
    ...
}
```

Естественно это использовать для трассирующего логгирования.

### Примечания
1. "self"

Что такое "self"?

"self" - это зарезервированное ключевое слово для указания самой декорируемой функции (вы можете использовать его для наименования своих декораторов, но воспользоваться ими будет нельзя :-). В этом и заключается улучшение по сравнению с Python декораторами: декорируемая функция может выступить декоратором самой себя, достаточно указать её в списке её декораторов! Пример использования:

```
#[decorators(decorator1, decorator2, self)]
fn func(arg: RetType) -> RetType {
    ...
}
```

2. Входная и выходная сигнатуры декоратора должны совпадать с выходной сигнатурой декорируемой функции, поскольку во-первых, декоратор потребляет функцию, а во-вторых, должен безболезненно её заменять. Эти ограничения налагает статическая типизация. В некоторой степени их можно ослабить реализацией типажей std::convert::From / std::convert::Into для типов аргументов функции.

Но я тут подумал, и понял, что проблемы вообще не существует, если вооружиться обобщенными функциями. А именно типичный декоратор будет выглядеть так:
```
fn decorator<T: std::fmt::Debug>(arg: T) -> T { 
    // some work
    ...
    arg
}
```

То есть условие только одно: тип возвращаемого декорируемой функцией значения должен реализовывать типаж "Debug", то есть поддерживать отладочную печать, а для этого зачастую достаточно указать "#[derive(Debug)]" для определения этого типа. Что забавно, работает даже для функций, которые как будто не возвращают никакого значения, то есть процедур. На самом деле они возвращают тип-унит "()", а синтаксический сахар позволяет не прописывать его явно.

3. Из предыдущего пункта следует, что входная сигнатура декоратора должна совпадать с выходной (таким образом, декораторы выступают своеобразными middlewares).

# Заключение
Если очень внимательно посмотреть, то можно заметить, что предлагаемая реализация не совсем точный аналог Python декораторов. Предлагаемые декораторы всегда получают результат уже выполненной обертываемой функции, в то время как Python декораторы получают обертываемую функцию как объект первого класса, а дальше вольны делать всё, что заблагорассудится: либо производить некую предварительную работу перед вызовом функции, либо производить пост-работу после вызова функции, либо вообще не вызывать функцию (что вообще делать некорректно, но здесь главное, что такая возможность имеется). Поэтому данная реализация реализует только половину корректной семантики Python декораторов.

# ОБНАРУЖЕННЫЕ ОГРАНИЧЕНИЯ
К сожалению, данная реализация не в состоянии обрабатывать некорректные определения функции: если в определении где-либо используются лишние пробелы, например, после `pub`, `fn` etc., то код не скомпилируется.
В планах значится переписывание с самописного орочьего парсера на человеческий из пакета `syn`.
