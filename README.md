# Что это?
Это улучшенная реализация сущности под названием "декоратор", позаимствованной из ЯП Python.

В Python определение и использование типичного декоратора выглядит так (Python псевдокод):
```
# декоратор
def decorator(func):
    # may be some work
    def inner(*args, *kwargs):
        # may be yet another work
        return func(*args, *kwargs)
    inner()

# применение декоратора к определению функции
@decorator
def func(...):
    ...

# или применение декоратора без использования синтаксического сахара
func = decorator(func)
```

## Как это предлагается делать для Rust?
Я предлагаю это делать с помощью указания специального атрибута перед определением функции. Атрибут реализуется процедурным макросом, поэтому для его использования необходимо подключить специальный крэйт, в котором он определен.

Это выглядит так (Rust псевдокод):
```
#![feature(use_extern_macros)]
#![feature(proc_macro)]

extern crate decorators;
use decorators::decorators; // квалифицированный импорт использован для краткости, но, разумеется, можно его и не использовать

fn decorator1(arg: RetType) -> RetType {
    // some work
    arg
}

fn decorator2(arg: RetType) -> RetType {
    // some work
    arg
}

#[decorators(decorator1, decorator2)]
fn func(arg: SomeType) -> RetType {
    ...
}
```

    "decorators(decorator1, decorator2)": "decorators" - подключенный процедурный макрос-атрибут,
                                          "decorator1, decorator2" - список декораторов; декораторы будут применяться в порядке обратном тому, в котором они здесь указаны.

В результате применения атрибута во время компиляции исходное определение функции будет заменено на определения двух сгенерированных функций:
```
// тело исходной функции с другим, сгенерированным именем (генерация тривиальна, возможны коллизии)
fn decorator1_decorator2(arg: SomeType) -> RetType {
    ...
}

// имя исходной функции с другим, сгенерированным телом
fn func(arg: SomeType) -> RetType {
    decorator1(decorator2(decorator1_decorator2(arg)))
}
```

### Примечания
1. "self"

Что такое "self"?

"self" - это зарезервированное ключевое слово для указания самой декорируемой функции (вы можете использовать его для наименования своих декораторов, но воспользоваться ими будет нельзя :-). В этом и заключается улучшение по сравнению с Python декораторами: декорируемая функция может выступить декоратором самой себя, достаточно указать её в списке её декораторов! Пример использования:

```
#[decorators(decorator1, decorator2, self)]
fn func(arg: RetType) -> RetType {
    ...
}
```

2. Входная и выходная сигнатуры декоратора должны совпадать с выходной сигнатурой декорируемой функции, поскольку во-первых, декоратор потребляет функцию, а во-вторых, должен безболезненно её заменять. Эти ограничения налагает статическая типизация. В некоторой степени их можно ослабить реализацией типажей std::convert::From / std::convert::Into для типов аргументов функции.

3. Из предыдущего пункта следует, что входная сигнатура декоратора должна совпадать с выходной (таким образом, декораторы выступают своеобразными middlewares).